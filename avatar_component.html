<!DOCTYPE html>
<html>
<head>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
        background: #000;
        overflow: hidden;
        width: 100%;
        height: 100%;
    }
    #avatar-container {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
    }
    #avatar-container video {
        position: absolute;
        top: 0; left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: opacity 0.15s ease;
        opacity: 0;
        z-index: 1;
    }
    #video-idle {
        opacity: 1;
        z-index: 2;
    }
    /* Status bar */
    #status-bar {
        position: absolute;
        bottom: 8px; left: 8px;
        color: rgba(255,255,255,0.6);
        font-family: 'Segoe UI', sans-serif;
        font-size: 11px;
        z-index: 10;
        pointer-events: none;
    }
</style>
</head>
<body>
    <div id="avatar-container">
        <video id="video-idle" loop muted autoplay playsinline></video>
        <video id="video-normal" loop muted playsinline></video>
        <video id="video-strong" loop muted playsinline></video>
    </div>
    <audio id="audio-player" style="display:none;"></audio>
    <div id="status-bar">待機中...</div>

<script>
    const videoIdle = document.getElementById('video-idle');
    const videoNormal = document.getElementById('video-normal');
    const videoStrong = document.getElementById('video-strong');
    const audioPlayer = document.getElementById('audio-player');
    const statusBar = document.getElementById('status-bar');

    // Set video sources from data attributes passed by Streamlit
    const IDLE_SRC = '__IDLE_SRC__';
    const NORMAL_SRC = '__NORMAL_SRC__';
    const STRONG_SRC = '__STRONG_SRC__';

    videoIdle.src = IDLE_SRC;
    videoNormal.src = NORMAL_SRC;
    videoStrong.src = STRONG_SRC;

    // Start all videos muted (for preloading)
    [videoIdle, videoNormal, videoStrong].forEach(v => {
        v.play().catch(e => console.warn('Autoplay blocked:', e));
    });

    function showVideo(target) {
        [videoIdle, videoNormal, videoStrong].forEach(v => {
            if (v === target) {
                v.style.opacity = '1';
                v.style.zIndex = '2';
            } else {
                v.style.opacity = '0';
                v.style.zIndex = '1';
            }
        });
    }

    // Listen for messages from Streamlit (via postMessage)
    window.addEventListener('message', (event) => {
        const data = event.data;
        if (!data || data.type !== 'avatar_command') return;

        if (data.action === 'play_audio') {
            const audioB64 = data.audio_b64;
            const emotion = (data.emotion || 'Neutral').toLowerCase();
            const responseText = data.response_text || '';

            // Show response text in status
            statusBar.textContent = responseText.substring(0, 60) + (responseText.length > 60 ? '...' : '');

            // Determine which talking video
            const strongEmotions = ['angry', 'power', 'strong', 'joy'];
            const isStrong = strongEmotions.includes(emotion);
            const talkingVideo = isStrong ? videoStrong : videoNormal;

            // Create audio blob from base64
            const byteChars = atob(audioB64);
            const byteNumbers = new Array(byteChars.length);
            for (let i = 0; i < byteChars.length; i++) {
                byteNumbers[i] = byteChars.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            const blob = new Blob([byteArray], { type: 'audio/mpeg' });
            const url = URL.createObjectURL(blob);

            audioPlayer.src = url;

            audioPlayer.onplay = () => {
                talkingVideo.play().catch(() => {});
                showVideo(talkingVideo);
            };

            audioPlayer.onended = () => {
                showVideo(videoIdle);
                statusBar.textContent = '待機中...';
                URL.revokeObjectURL(url);
                // Notify Streamlit that playback is done
                window.parent.postMessage({type: 'playback_done'}, '*');
            };

            audioPlayer.onerror = () => {
                showVideo(videoIdle);
                statusBar.textContent = '再生エラー';
            };

            audioPlayer.play().catch(e => {
                console.error('Audio play error:', e);
                statusBar.textContent = '再生エラー (ブラウザの制限)';
            });
        }

        if (data.action === 'set_status') {
            statusBar.textContent = data.text || '待機中...';
        }
    });

    // Initial status
    showVideo(videoIdle);
    statusBar.textContent = '待機中...';
</script>
</body>
</html>
