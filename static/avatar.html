<!DOCTYPE html>
<html style="height: 100%; width: 100%;">
<head>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100% !important; width: 100% !important; background: #000; overflow: hidden; }
    #avatar-container { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; overflow: hidden; }
    #avatar-container video { position: absolute; display: block !important; width: 100% !important; height: 100% !important; object-fit: cover; opacity: 0; z-index: 1; }
    #status-bar { 
        position: absolute; 
        bottom: 30px; 
        left: 50%; 
        transform: translateX(-50%); 
        width: 90%; 
        color: #ffffff; 
        font-size: 24px; 
        font-weight: bold;
        line-height: 1.4;
        text-align: center;
        z-index: 1000; 
        background: transparent; /* èƒŒæ™¯ã‚’å®Œå…¨ã«é€é */
        /* å¼·ã„é»’ã®ç¸å–ã‚Šã¨ãƒ‰ãƒ­ãƒƒãƒ—ã‚·ãƒ£ãƒ‰ã‚¦ã§è¦–èªæ€§ã‚’ç¢ºä¿ */
        text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 0px 4px 6px rgba(0,0,0,0.8);
        font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif; 
        display: none; 
    }
    #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 2000; cursor: pointer; }
    .play-icon { width: 80px; height: 80px; background: #0078d7; border-radius: 50%; display: flex; justify-content: center; align-items: center; border: 4px solid #fff; }
    .play-icon::after { content: ''; border-top: 20px solid transparent; border-bottom: 20px solid transparent; border-left: 30px solid #fff; margin-left: 10px; }
</style>
</head>
<body>
    <div id="avatar-container">
        <video id="video-idle" loop muted playsinline></video>
        <video id="video-normal" loop muted playsinline></video>
        <video id="video-strong" loop muted playsinline></video>
        <video id="video-wait" loop muted playsinline></video>
        <div id="overlay">
            <div style="text-align: center;">
                <div class="play-icon"></div>
                <h2 style="color:#fff; margin-top:30px; font-family: sans-serif;">START AVATAR</h2>
            </div>
        </div>
        <div id="status-bar">Initializing...</div>
    </div>
    <audio id="audio-player" style="display:none;"></audio>

<script>
/**
 * Cloud-Native In-Memory Architecture:
 * 1. Read all videos/tasks from window.AVATAR_APP_DATA injected by Python.
 * 2. No filesystem 'fetch' calls.
 * 3. Use Data URIs for absolute stability.
 */
(function() {
    // ğŸš€ Data Injection from Python
    const appData = window.AVATAR_APP_DATA || { video_urls: {}, task: null, sid: '', buster: Date.now() };
    const urls = appData.video_urls || {};
    const task = appData.task || {};
    const buster = appData.buster || Date.now();
    
    const v = {
        idle: document.getElementById('video-idle'),
        normal: document.getElementById('video-normal'),
        strong: document.getElementById('video-strong'),
        wait: document.getElementById('video-wait')
    };
    const audio = document.getElementById('audio-player');
    const status = document.getElementById('status-bar');
    const overlay = document.getElementById('overlay');

    let currentAudioUrl = null;

    // ğŸš€ GPUéè² è·ã‚’é˜²ããŸã‚ã€è¦‹ãˆãªã„å‹•ç”»ã¯ç¢ºå®Ÿã«ä¸€æ™‚åœæ­¢ï¼ˆpauseï¼‰ã™ã‚‹
    function show(type) {
        Object.keys(v).forEach(k => {
            if (k === type) {
                v[k].style.opacity = '1';
                v[k].style.zIndex = '100';
                v[k].play().catch(e => console.warn(e));
            } else {
                v[k].style.opacity = '0';
                v[k].style.zIndex = '1';
                v[k].pause(); 
            }
        });
    }

    // Persist 'started' state across iframe reloads
    let isStarted = sessionStorage.getItem('avatar_started') === 'true';
    let lastPlayedTaskId = sessionStorage.getItem('last_played_task_id') || null;

    function processTask(d) {
        if (!d || !d.task_id || d.task_id === lastPlayedTaskId) return;
        
        // Mark as seen
        if (d.task_id !== "processing") {
            sessionStorage.setItem('last_played_task_id', d.task_id);
            lastPlayedTaskId = d.task_id;
        }

        if (d.task_id === "processing") {
            show('wait');
            status.style.display = 'block';
            status.textContent = "ğŸ™ï¸ AIé˜ªå£æºå¤ªãŒå›ç­”ã‚’æº–å‚™ä¸­...";
            return;
        }

        // Generate Audio Blob from Base64
        const isS = d.is_initial_greeting ? false : ['angry', 'power', 'strong', 'joy'].includes(d.emotion.toLowerCase());
        const fullText = d.response_text || "";
        const segments = fullText.match(/[^ã€‚ã€ï¼ï¼Ÿ\n]+[ã€‚ã€ï¼ï¼Ÿ\n]*/g) || [fullText];
        let currentSegIndex = -1;

        if (currentAudioUrl) URL.revokeObjectURL(currentAudioUrl);
        const b = new Blob([Uint8Array.from(atob(d.audio_b64), c => c.charCodeAt(0))], { type: 'audio/mpeg' });
        currentAudioUrl = URL.createObjectURL(b);
        audio.src = currentAudioUrl;
        
        audio.onplay = () => { 
            show(isS ? 'strong' : 'normal'); 
            status.style.display = 'block'; 
        };

        audio.ontimeupdate = () => {
            if (!audio.duration) return;
            const progress = audio.currentTime / audio.duration;
            let cumulativeRatio = 0;
            let targetIndex = 0;
            for (let i = 0; i < segments.length; i++) {
                cumulativeRatio += segments[i].length / fullText.length;
                if (progress <= cumulativeRatio) { targetIndex = i; break; }
            }
            if (targetIndex !== currentSegIndex && segments[targetIndex]) {
                currentSegIndex = targetIndex;
                status.textContent = segments[targetIndex];
            }
        };

        audio.onended = () => { 
            show('idle'); 
            status.style.display = 'none'; 
            status.textContent = '';
            audio.ontimeupdate = null;
        };

        audio.play().catch(e => console.warn(e));
    }

    function startAvatar() {
        overlay.style.display = 'none';
        sessionStorage.setItem('avatar_started', 'true');
        isStarted = true;
        show('idle'); 
        // Initial process
        if (task) processTask(task);
    }

    overlay.onclick = startAvatar;

    // ğŸš€ Set Video Sources from URLs (Cachable)
    // Local Streamlit uses /static/ alias. Adding buster to avoid stale renders.
    v.idle.src = urls.idle ? `${urls.idle}?v=${buster}` : '';
    v.normal.src = urls.normal ? `${urls.normal}?v=${buster}` : '';
    v.strong.src = urls.strong ? `${urls.strong}?v=${buster}` : '';
    v.wait.src = urls.wait ? `${urls.wait}?v=${buster}` : '';

    // If already started, go straight to idle/processing
    if (isStarted) {
        overlay.style.display = 'none';
        show('idle');
        if (task) processTask(task);
    }
})();
</script>
</body>
</html>
