<!DOCTYPE html>
<html style="height: 100%; width: 100%;">
<head>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100% !important; width: 100% !important; background: #000; overflow: hidden; }
    #avatar-container { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; overflow: hidden; }
    
    /* Double Buffering Layers */
    .v-layer { 
        position: absolute; 
        display: block !important; 
        width: 100% !important; 
        height: 100% !important; 
        object-fit: cover; 
        opacity: 0; 
        z-index: 1; 
        transition: opacity 0.4s ease-in-out; /* Smooth cross-fade */
    }
    .v-layer.active { opacity: 1; z-index: 10; }

    #status-bar { 
        position: absolute; 
        bottom: 30px; 
        left: 50%; 
        transform: translateX(-50%); 
        width: 90%; 
        color: #ffffff; 
        font-size: 24px; 
        font-weight: bold;
        line-height: 1.4;
        text-align: center;
        z-index: 1000; 
        background: transparent; 
        text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 0px 4px 6px rgba(0,0,0,0.8);
        font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif; 
        display: none; 
    }
    #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 2000; cursor: pointer; }
    .play-icon { width: 80px; height: 80px; background: #0078d7; border-radius: 50%; display: flex; justify-content: center; align-items: center; border: 4px solid #fff; }
    .play-icon::after { content: ''; border-top: 20px solid transparent; border-bottom: 20px solid transparent; border-left: 30px solid #fff; margin-left: 10px; }
</style>
</head>
<body>
    <div id="avatar-container">
        <!-- Dual Layers for Seamless Transitions -->
        <video id="v-a" class="v-layer" loop muted playsinline aria-hidden="true"></video>
        <video id="v-b" class="v-layer" loop muted playsinline aria-hidden="true"></video>
        
        <div id="overlay">
            <div style="text-align: center;">
                <div class="play-icon"></div>
                <h2 style="color:#fff; margin-top:30px; font-family: sans-serif;">AIÈò™Âè£Ê∫êÂ§™„ÇíËµ∑Âãï</h2>
            </div>
        </div>
        <div id="status-bar">Initializing...</div>
    </div>
    <audio id="audio-player" style="display:none;"></audio>

<script>
(function() {
    const appData = window.AVATAR_APP_DATA || { video_urls: {}, task: null, sid: '', buster: Date.now() };
    const urls = appData.video_urls || {};
    const task = appData.task || {};
    const buster = appData.buster || Date.now();
    
    const layers = [
        document.getElementById('v-a'),
        document.getElementById('v-b')
    ];
    const audio = document.getElementById('audio-player');
    const status = document.getElementById('status-bar');
    const overlay = document.getElementById('overlay');

    let activeIdx = 0; // Current visible layer
    let currentAudioUrl = null;
    let isStarted = sessionStorage.getItem('avatar_started') === 'true';
    let lastPlayedTaskId = sessionStorage.getItem('last_played_task_id') || null;

    /**
     * Seamless Switch via Double Buffering
     */
    function switchVideo(type) {
        const nextUrl = urls[type];
        if (!nextUrl) return;

        const nextIdx = (activeIdx + 1) % 2;
        const currentLayer = layers[activeIdx];
        const nextLayer = layers[nextIdx];
        const fullNextUrl = `${nextUrl}?v=${buster}`;

        // If same video is already playing, just ensure it's playing
        if (nextLayer.src.includes(nextUrl) && nextLayer.classList.contains('active')) {
            nextLayer.play().catch(e => {});
            return;
        }

        // 1. Pre-load in background layer
        nextLayer.src = fullNextUrl;
        nextLayer.load();

        // 2. Trigger swap when ready
        nextLayer.oncanplay = () => {
            nextLayer.oncanplay = null; // Prevent multi-trigger
            
            // Start background playback
            nextLayer.play().then(() => {
                // Perform Cross-fade
                nextLayer.classList.add('active');
                currentLayer.classList.remove('active');
                
                // Update pointers
                activeIdx = nextIdx;
                
                // Cleanup previous layer after fade finishes
                setTimeout(() => {
                    if (layers[(nextIdx + 1) % 2] !== nextLayer) {
                        layers[(nextIdx + 1) % 2].pause();
                    }
                }, 500);
            }).catch(e => console.warn("Play failed:", e));
        };
    }

    function processTask(d) {
        if (!d || !d.task_id || d.task_id === lastPlayedTaskId) return;
        
        if (d.task_id !== "waiting" && d.task_id !== "processing") {
            sessionStorage.setItem('last_played_task_id', d.task_id);
            lastPlayedTaskId = d.task_id;
        }

        if (d.task_id === "waiting" || d.task_id === "processing") {
            switchVideo('wait');
            status.style.display = 'block';
            status.textContent = "üéôÔ∏è AIÈò™Âè£Ê∫êÂ§™„ÅåÂõûÁ≠î„ÇíÊ∫ñÂÇô‰∏≠...";
            return;
        }

        const isS = d.is_initial_greeting ? false : ['angry', 'power', 'strong', 'joy'].includes(d.emotion.toLowerCase());
        const fullText = d.response_text || "";
        const segments = fullText.match(/[^„ÄÇ„ÄÅÔºÅÔºü\n]+[„ÄÇ„ÄÅÔºÅÔºü\n]*/g) || [fullText];
        let currentSegIndex = -1;

        if (currentAudioUrl) URL.revokeObjectURL(currentAudioUrl);
        const b = new Blob([Uint8Array.from(atob(d.audio_b64), c => c.charCodeAt(0))], { type: 'audio/mpeg' });
        currentAudioUrl = URL.createObjectURL(b);
        audio.src = currentAudioUrl;
        
        audio.onplay = () => { 
            switchVideo(isS ? 'strong' : 'normal'); 
            status.style.display = 'block'; 
        };

        audio.ontimeupdate = () => {
            if (!audio.duration) return;
            const progress = audio.currentTime / audio.duration;
            let cumulativeRatio = 0;
            let targetIndex = 0;
            for (let i = 0; i < segments.length; i++) {
                cumulativeRatio += segments[i].length / fullText.length;
                if (progress <= cumulativeRatio) { targetIndex = i; break; }
            }
            if (targetIndex !== currentSegIndex && segments[targetIndex]) {
                currentSegIndex = targetIndex;
                status.textContent = segments[targetIndex];
            }
        };

        audio.onended = () => { 
            switchVideo('idle'); 
            status.style.display = 'none'; 
            status.textContent = '';
            audio.ontimeupdate = null;
        };

        audio.play().catch(e => console.warn(e));
    }

    function startAvatar() {
        overlay.style.display = 'none';
        sessionStorage.setItem('avatar_started', 'true');
        isStarted = true;
        
        // Load initial idle
        layers[activeIdx].src = `${urls.idle}?v=${buster}`;
        layers[activeIdx].classList.add('active');
        layers[activeIdx].play().catch(e => {});

        if (task) processTask(task);
    }

    overlay.onclick = startAvatar;

    if (isStarted) {
        overlay.style.display = 'none';
        layers[activeIdx].src = `${urls.idle}?v=${buster}`;
        layers[activeIdx].classList.add('active');
        layers[activeIdx].play().catch(e => {});
        if (task) processTask(task);
    }
})();
</script>
</body>
</html>
